<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./2048-favicon.ico">
    <title>2048</title>
    <link rel="stylesheet" href="platform/platform.css">
    <script src="platform/platform.js"></script>

    <!-- Persist language BEFORE paint (same as portal) -->
    <script>
        (function () {
            var KEY = 'portal.lang';
            var m = (location.search.match(/[?&]lang=(en|fr|zh)\b/) || [])[1];
            var saved = localStorage.getItem(KEY);
            var lang = m || saved || 'en';
            document.documentElement.setAttribute('lang', lang);
            localStorage.setItem(KEY, lang);
        })();
    </script>
    <script>
        // Localized labels for the sound toggle
        (function () {
            window._2048_I18N = {
                en: { soundOn: 'Sound: On', soundOff: 'Sound: Off' },
                fr: { soundOn: 'Son : Activé', soundOff: 'Son : Coupé' },
                zh: { soundOn: '声音：开', soundOff: '声音：关' },
            };
            window._2048_lang = document.documentElement.getAttribute('lang') || 'en';
            if (!window._2048_I18N[window._2048_lang]) window._2048_lang = 'en';
        })();
    </script>

    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #faf8ef;
            min-height: 100svh;
            /* safe mobile viewport height */
        }

        /* Only show the active language */
        :root [lang] {
            display: none;
        }

        html[lang="en"] [lang="en"],
        html[lang="fr"] [lang="fr"],
        html[lang="zh"] [lang="zh"] {
            display: inline;
        }

        html,
        body {
            overflow-x: hidden;
        }

        /* kill horizontal scrollbars */

        #game-container {
            text-align: center;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 30px;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-auto-rows: 1fr;
            /* pairs with aspect-ratio to keep squares */
            grid-gap: 15px;
            background: #bbada0;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            /* Width rules: shrink on mobile, cap on desktop */
            width: min(92vw, 460px);
            touch-action: none;
            /* let us handle swipes without scrolling */
        }

        .tile {
            aspect-ratio: 1 / 1;
            /* <-- replaces fixed width/height */
            width: 100%;
            height: auto;
            background: #cdc1b4;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            /* auto-scale numbers: 18px..36px depending on viewport */
            font-size: clamp(18px, 6vw, 36px);
            font-weight: bold;
            color: #776e65;
            transition: transform 0.08s ease, background-color 0.08s ease;
        }

        .tile-2 {
            background: #eee4da
        }

        .tile-4 {
            background: #ede0c8
        }

        .tile-8 {
            background: #f2b179;
            color: #f9f6f2
        }

        .tile-16 {
            background: #f59563;
            color: #f9f6f2
        }

        .tile-32 {
            background: #f67c5f;
            color: #f9f6f2
        }

        .tile-64 {
            background: #f65e3b;
            color: #f9f6f2
        }

        .tile-128 {
            background: #edcf72;
            color: #f9f6f2
        }

        .tile-256 {
            background: #edcc61;
            color: #f9f6f2
        }

        .tile-512 {
            background: #edc850;
            color: #f9f6f2
        }

        .tile-1024 {
            background: #edc53f;
            color: #f9f6f2
        }

        .tile-2048 {
            background: #edc22e;
            color: #f9f6f2
        }

        .label-row {
            font-size: 18px;
            margin: 10px 0;
        }

        #new-game,
        #undo,
        #restart {
            font-size: 18px;
            padding: 10px 20px;
            margin: 10px;
            background: #8f7a66;
            color: #f9f6f2;
            border: none;
            border-radius: 3px;
            cursor: pointer
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(238, 228, 218, .73);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: #776e65
        }

        .hidden {
            display: none !important
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 20px
        }

        .gamepad {
            display: grid;
            grid-template-columns: repeat(3, 70px);
            grid-template-rows: repeat(3, 70px);
            gap: 8px;
            padding: 15px;
            background: #bbada0;
            border-radius: 6px;
            image-rendering: pixelated
        }

        .gamepad button {
            width: 70px;
            height: 70px;
            border: 0;
            background: #cdc1b4;
            cursor: pointer;
            position: relative;
            padding: 0;
            image-rendering: pixelated;
            box-shadow: inset -4px -4px 0 0 #a99d90, inset 4px 4px 0 0 #ede0c8
        }

        .gamepad button:active {
            background: #bcb0a3;
            box-shadow: inset 4px 4px 0 0 #a99d90, inset -4px -4px 0 0 #ede0c8;
            transform: translate(2px, 2px)
        }

        .gamepad button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border: 10px solid transparent
        }

        .gamepad .up::after {
            border-bottom: 20px solid #776e65;
            border-top: 0;
            margin-top: -5px
        }

        .gamepad .down::after {
            border-top: 20px solid #776e65;
            border-bottom: 0;
            margin-top: 5px
        }

        .gamepad .left::after {
            border-right: 20px solid #776e65;
            border-left: 0;
            margin-left: -5px
        }

        .gamepad .right::after {
            border-left: 20px solid #776e65;
            border-right: 0;
            margin-left: 5px
        }

        .gamepad .up {
            grid-area: 1/2/2/3
        }

        .gamepad .left {
            grid-area: 2/1/3/2
        }

        .gamepad .right {
            grid-area: 2/3/3/4
        }

        .gamepad .down {
            grid-area: 3/2/4/3
        }

        .tile-merged {
            animation: pop .12s ease-out;
        }

        @keyframes pop {
            from {
                transform: scale(0.9);
            }

            to {
                transform: scale(1);
            }
        }

        @media (max-width:768px) {
            #game-container {
                flex-direction: column;
                align-items: center;
            }

            #game-board {
                width: min(94vw, 520px);
            }

            /* a touch wider on phones */

            .game-content {
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .controls-container {
                order: 2;
                width: 100%;
                align-items: center
            }

            .gamepad {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px)
            }

            .gamepad button {
                width: 80px;
                height: 80px
            }
        }

        /* Optional tiny hover “pop” (ignored on touch) */
        @media (hover:hover) and (pointer:fine) {
            .tile:hover {
                transform: scale(1.02);
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div class="game-content">
            <!-- Titles -->
            <h1 lang="en">2048</h1>
            <h1 lang="fr">2048</h1>
            <h1 lang="zh">2048</h1>

            <!-- Labels -->
            <div class="label-row">
                <span id="score-label" lang="en">Score:</span>
                <span id="score-label-fr" lang="fr">Score&nbsp;:</span>
                <span id="score-label-zh" lang="zh">分数：</span>
                <span id="score-value">0</span>
            </div>
            <div class="label-row">
                <span id="high-score-label" lang="en">High Score:</span>
                <span id="high-score-label-fr" lang="fr">Meilleur score&nbsp;:</span>
                <span id="high-score-label-zh" lang="zh">最高分：</span>
                <span id="high-score-value">0</span>
            </div>

            <!-- Buttons -->
            <button id="new-game" lang="en">New Game</button>
            <button id="new-game-fr" lang="fr">Nouvelle partie</button>
            <button id="new-game-zh" lang="zh">新游戏</button>

            <button id="undo" lang="en">Undo</button>
            <button id="undo-fr" lang="fr">Annuler</button>
            <button id="undo-zh" lang="zh">撤销</button>
            <button id="soundBtn"></button>

            <div id="game-board"></div>
        </div>

        <div class="controls-container">
            <div class="gamepad">
                <button class="up"></button>
                <button class="left"></button>
                <button class="right"></button>
                <button class="down"></button>
            </div>
        </div>
    </div>

    <!-- Overlay -->
    <div id="game-over" class="hidden">
        <h2 id="over-title" lang="en">Game Over!</h2>
        <h2 id="over-title-fr" lang="fr">Partie terminée&nbsp;!</h2>
        <h2 id="over-title-zh" lang="zh">游戏结束！</h2>

        <p>
            <span lang="en">Your score:</span>
            <span lang="fr">Votre score&nbsp;:</span>
            <span lang="zh">你的分数：</span>
            <span id="final-score"></span>
        </p>

        <button id="restart" lang="en">Play Again</button>
        <button id="restart-fr" lang="fr">Rejouer</button>
        <button id="restart-zh" lang="zh">再来一局</button>
    </div>

    <script>
        // --- Minimal SFX (no audio files) -----------------------------------------
        const Snd2048 = (() => {
            let ctx = null, muted = false, inited = false;

            function ensure() { if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)(); }
            function unlock() { ensure(); if (ctx && ctx.state === 'suspended') ctx.resume(); }
            function env(osc, t0, dur = 0.12, vol = 0.07) {
                const g = ctx.createGain();
                g.gain.setValueAtTime(0, t0);
                g.gain.linearRampToValueAtTime(vol, t0 + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                osc.connect(g); g.connect(ctx.destination);
            }
            function blip(freq = 440, dur = 0.09, type = 'square', vol = 0.07, detune = 0) {
                if (muted) return;
                ensure(); if (!ctx) return;
                const t0 = ctx.currentTime;
                const osc = ctx.createOscillator();
                osc.type = type; osc.frequency.value = freq; osc.detune.value = detune;
                env(osc, t0, dur, vol); osc.start(t0); osc.stop(t0 + dur);
            }
            function chord(freqs, step = 70) {
                if (muted) return;
                freqs.forEach((f, i) => setTimeout(() => blip(f, 0.1, 'square', 0.06), i * step));
            }

            // Map tile value → a pleasant frequency
            function freqForValue(v) {
                // values are powers of 2; use log2 as a step index
                const idx = Math.log2(v);          // 1..11 (2..2048)
                return 240 + idx * 45;             // 240Hz base, ~45Hz per step
            }

            const play = {
                move() { blip(320, 0.06, 'square', 0.05); },               // any successful move without merge
                bump() { blip(180, 0.05, 'sawtooth', 0.06); },             // invalid move (nothing moved)
                spawn() { blip(520, 0.06, 'triangle', 0.05, -20); },        // new tile appears
                undo() { blip(480, 0.06, 'triangle', 0.05); blip(300, 0.09, 'triangle', 0.05); },
                over() { chord([500, 380, 300], 110); },                   // game over
                new() { chord([420, 560], 90); },                         // new game
                win() { chord([523, 659, 784, 988], 100); },              // reached 2048 (or more)
                merge(values) {                                             // values = array of merged tile values
                    if (!values || !values.length) return;
                    // Play up to 4 short notes, pitched by merged values
                    values.slice(0, 4).forEach((v, i) => setTimeout(() => blip(freqForValue(v), 0.08, 'square', 0.065), i * 55));
                },
            };

            function updateBtn() {
                const B = document.getElementById('soundBtn');
                if (!B) return;
                const L = (window._2048_I18N && window._2048_I18N[window._2048_lang]) || window._2048_I18N.en;
                B.textContent = muted ? L.soundOff : L.soundOn;
                B.setAttribute('aria-pressed', muted ? 'true' : 'false');
            }

            function toggle() { muted = !muted; updateBtn(); }
            function init() {
                if (inited) return; inited = true;
                updateBtn();
                // Mobile: unlock audio context on first gesture
                ['keydown', 'mousedown', 'touchstart'].forEach(ev =>
                    window.addEventListener(ev, unlock, { once: true, passive: true })
                );
            }

            return { play, toggle, init };
        })();
    </script>

    <script>
        // Optional: also set dynamic <title> per language
        (function () {
            var l = document.documentElement.getAttribute('lang') || 'en';
            var titles = { en: '2048 Game', fr: 'Jeu 2048', zh: '2048 游戏' };
            document.title = titles[l] || titles.en;
        })();

        class Game2048 {
            constructor() {
                this.board = Array(4).fill().map(() => Array(4).fill(0));
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('highScore')) || 0;
                this.gameBoard = document.getElementById('game-board');
                this.scoreDisplay = document.getElementById('score-value');
                this.highScoreDisplay = document.getElementById('high-score-value');
                this.newGameBtn = document.getElementById('new-game');
                this.newGameBtnFr = document.getElementById('new-game-fr');
                this.newGameBtnZh = document.getElementById('new-game-zh');
                this.undoBtn = document.getElementById('undo');
                this.undoBtnFr = document.getElementById('undo-fr');
                this.undoBtnZh = document.getElementById('undo-zh');
                this.gameOverOverlay = document.getElementById('game-over');
                this.finalScoreDisplay = document.getElementById('final-score');
                this.restartBtn = document.getElementById('restart');
                this.restartBtnFr = document.getElementById('restart-fr');
                this.restartBtnZh = document.getElementById('restart-zh');
                this.previousState = null;
                this.init();
            }

            init() {
                const start = () => this.resetGame();
                [this.newGameBtn, this.newGameBtnFr, this.newGameBtnZh].forEach(b => b.addEventListener('click', start));
                [this.undoBtn, this.undoBtnFr, this.undoBtnZh].forEach(b => b.addEventListener('click', () => this.undo()));
                [this.restartBtn, this.restartBtnFr, this.restartBtnZh].forEach(b => b.addEventListener('click', start));
                document.addEventListener('keydown', this.handleKeyPress.bind(this));
                this.resetGame();
                this.addSwipeControls();
                Snd2048.init(); // already called outside; calling again is harmless (no-op)
            }

            resetGame() {
                if (window.PlatformSDK) {
                    PlatformSDK.endGame();                       // end prior round if any (safe no-op)
                    PlatformSDK.startGame('GAME_2048');          // unique id for this game
                }
                this.board = Array(4).fill().map(() => Array(4).fill(0));
                this.score = 0;
                this.gameOverOverlay.classList.add('hidden');
                this.addRandomTile();
                this.addRandomTile();
                this.updateDisplay();
                Snd2048.play.new();
            }

            addRandomTile() {
                const empty = [];
                for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) if (this.board[i][j] === 0) empty.push({ i, j });
                if (empty.length) {
                    const { i, j } = empty[Math.floor(Math.random() * empty.length)];
                    this.board[i][j] = Math.random() < 0.9 ? 2 : 4;
                    Snd2048.play.spawn();  // <— add this
                }
            }

            updateDisplay() {
                this.gameBoard.innerHTML = '';
                // Copy merges so we only highlight as many tiles as actually merged
                const mergedLeft = (this._lastMerged && this._lastMerged.length)
                    ? this._lastMerged.slice()
                    : [];
                for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) {
                    const tile = document.createElement('div');
                    const val = this.board[i][j];
                    tile.className = `tile${val ? ` tile-${val}` : ''}`;
                    tile.textContent = val || '';
                    // Add a quick pop animation to tiles that correspond to merged values
                    if (val && mergedLeft.length) {
                        const k = mergedLeft.indexOf(val);
                        if (k !== -1) {
                            tile.classList.add('tile-merged');
                            mergedLeft.splice(k, 1); // consume one occurrence
                        }
                    }
                    this.gameBoard.appendChild(tile);
                }
                this.scoreDisplay.textContent = this.score;
                this.highScoreDisplay.textContent = this.highScore;
            }

            handleKeyPress(e) {
                let moved = false;
                if (e.key === 'ArrowUp') moved = this.move('up');
                else if (e.key === 'ArrowDown') moved = this.move('down');
                else if (e.key === 'ArrowLeft') moved = this.move('left');
                else if (e.key === 'ArrowRight') moved = this.move('right');
                if (moved) this.afterMove();
                else Snd2048.play.bump();   // <— add this
            }

            addSwipeControls() {
                const el = this.gameBoard;
                let sx = 0, sy = 0, tracking = false;

                const start = (x, y) => { sx = x; sy = y; tracking = true; };
                const end = (x, y) => {
                    if (!tracking) return;
                    tracking = false;
                    const dx = x - sx, dy = y - sy;
                    const adx = Math.abs(dx), ady = Math.abs(dy);
                    const TH = 24; // px threshold to avoid accidental taps

                    if (adx < TH && ady < TH) return;          // ignore tiny moves
                    let moved = false;
                    if (adx > ady) moved = this.move(dx < 0 ? 'left' : 'right');
                    else moved = this.move(dy < 0 ? 'up' : 'down');
                    if (moved) this.afterMove(); else Snd2048.play.bump();
                };

                el.addEventListener('touchstart', (e) => {
                    if (!e.touches || !e.touches[0]) return;
                    // prevent page scroll while swiping over board
                    e.preventDefault();
                    const t = e.touches[0];
                    start(t.clientX, t.clientY);
                }, { passive: false });

                el.addEventListener('touchend', (e) => {
                    const t = (e.changedTouches && e.changedTouches[0]) || null;
                    if (!t) return;
                    e.preventDefault();
                    end(t.clientX, t.clientY);
                }, { passive: false });

                // (Optional) mouse drag support
                el.addEventListener('mousedown', (e) => start(e.clientX, e.clientY));
                window.addEventListener('mouseup', (e) => end(e.clientX, e.clientY));
            }

            afterMove() {
                // Play merge chime (pitched by values) or a plain move tick
                if (this._lastMerged && this._lastMerged.length) {
                    Snd2048.play.merge(this._lastMerged);
                    if (this._lastMerged.some(v => v >= 2048)) {
                        Snd2048.play.win(); // hit 2048 or above
                        if (window.PlatformSDK) {
                            PlatformSDK.addPoints(1, '2048: level cleared'); // optional
                        }
                    }
                } else {
                    Snd2048.play.move();
                }
                this.addRandomTile();
                this.updateDisplay();
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('highScore', this.highScore);
                }
                if (this.checkGameOver()) this.gameOver();
            }

            move(direction) {
                this.previousState = { board: this.board.map(r => [...r]), score: this.score };
                let moved = false;
                if (direction === 'up') moved = this.moveUp();
                else if (direction === 'down') moved = this.moveDown();
                else if (direction === 'left') moved = this.moveLeft();
                else if (direction === 'right') moved = this.moveRight();
                if (moved) { /* afterMove handled by caller */ }
                return moved;
            }

            moveUp() {
                return this.moveVertical(col => {
                    let c = col.filter(x => x !== 0);
                    let merges = [];
                    for (let i = 0; i < c.length - 1; i++) { if (c[i] === c[i + 1]) { c[i] *= 2; merges.push(c[i]); this.score += c[i]; c.splice(i + 1, 1); } }
                    while (c.length < 4) c.push(0); return { line: c, merges };
                });
            }
            moveDown() {
                return this.moveVertical(col => {
                    let c = col.filter(x => x !== 0);
                    let merges = [];
                    for (let i = c.length - 1; i > 0; i--) { if (c[i] === c[i - 1]) { c[i] *= 2; merges.push(c[i]); this.score += c[i]; c.splice(i - 1, 1); } }
                    while (c.length < 4) c.unshift(0); return { line: c, merges };
                });
            }
            moveLeft() {
                return this.moveHorizontal(row => {
                    let r = row.filter(x => x !== 0);
                    let merges = [];
                    for (let i = 0; i < r.length - 1; i++) {
                        if (r[i] === r[i + 1]) { r[i] *= 2; merges.push(r[i]); this.score += r[i]; r.splice(i + 1, 1); }
                    }
                    while (r.length < 4) r.push(0); return { line: r, merges };
                });
            }
            moveRight() {
                return this.moveHorizontal(row => {
                    let r = row.filter(x => x !== 0);
                    let merges = [];
                    for (let i = r.length - 1; i > 0; i--) { if (r[i] === r[i - 1]) { r[i] *= 2; merges.push(r[i]); this.score += r[i]; r.splice(i - 1, 1); } }
                    while (r.length < 4) r.unshift(0); return { line: r, merges };
                });
            }

            moveVertical(cb) {
                let moved = false;
                this._lastMerged = [];
                for (let i = 0; i < 4; i++) {
                    const orig = this.board.map(r => r[i]);
                    const { line, merges } = cb(orig);
                    for (let j = 0; j < 4; j++) {
                        if (this.board[j][i] !== line[j]) {  // <-- compare to line
                            this.board[j][i] = line[j];
                            moved = true;
                        }
                    }
                    if (merges && merges.length) this._lastMerged.push(...merges);
                }
                return moved;
            }

            moveHorizontal(cb) {
                let moved = false;
                this._lastMerged = [];
                for (let i = 0; i < 4; i++) {
                    const orig = [...this.board[i]];
                    const { line, merges } = cb(orig);
                    if (orig.join(',') !== line.join(',')) { // <-- compare to line
                        this.board[i] = line;
                        moved = true;
                    }
                    if (merges && merges.length) this._lastMerged.push(...merges);
                }
                return moved;
            }

            checkGameOver() {
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        if (this.board[i][j] === 0) return false;
                        if (i < 3 && this.board[i][j] === this.board[i + 1][j]) return false;
                        if (j < 3 && this.board[i][j] === this.board[i][j + 1]) return false;
                    }
                }
                return true;
            }

            gameOver() {
                if (window.PlatformSDK) PlatformSDK.endGame();
                this.finalScoreDisplay.textContent = this.score;
                this.gameOverOverlay.classList.remove('hidden');
                Snd2048.play.over();
            }

            undo() {
                if (!this.previousState) return;
                this.board = this.previousState.board.map(r => [...r]);
                this.score = this.previousState.score;
                this.updateDisplay();
                this.previousState = null;
                Snd2048.play.undo();
            }
        }

        // Start game
        new Game2048();

        document.getElementById('soundBtn').onclick = () => Snd2048.toggle();
        Snd2048.init();

        // On-screen gamepad
        document.querySelectorAll('.gamepad button').forEach(button => {
            ['mousedown', 'touchstart'].forEach(type => {
                button.addEventListener(type, e => {
                    e.preventDefault();
                    const map = { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' };
                    const direction = [...button.classList].find(c => map[c]);
                    if (!direction) return;
                    document.dispatchEvent(new KeyboardEvent('keydown', { key: map[direction] }));
                });
            });
        });
        window.addEventListener('beforeunload', () => {
            if (window.PlatformSDK) PlatformSDK.endGame();
        });
    </script>
</body>

</html>